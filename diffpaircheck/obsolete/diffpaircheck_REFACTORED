#!/usr/bin/env python3
"""
Differential Pair Length Checker (CustomTkinter Version)

This GUI application loads a text file (for example, an Eagle design signal report)
that contains a list of signals and their lengths (in mm). It keeps only signals whose
names end with "_N" or "_P" and groups them into differential pairs based on the 
common base name. The expected signal name format is:

    Extension + "_" + BaseName + "_" + (N or P)
    
or simply

    BaseName + "_" + (N or P)

For grouping, the “base name” is extracted by taking the token immediately before the
trailing channel indicator. However, if the signal name contains an expansion (i.e. more
than two tokens), the grouping key is built from the first token (the expansion) and the
token immediately before the trailing channel indicator. That way signals like 
"HDMI0_TDMS0_N" and "HDMI1_TDMS0_N" are grouped separately while still allowing for proper
interface recommendation.

For each pair, you may assign an interface (e.g. USB 3.0, PCIe Gen4, etc.) from the dropdown.
When you click “Run Check,” the program verifies:
  - That each differential pair’s two channels match within the interface’s pair tolerance.
  - If more than one pair is assigned to an interface (and if an inter‑pair tolerance is defined),
    that the average lengths of the pairs are sufficiently matched.
  - Additionally, for HDMI 1.4 the TMDSCK (clock) pair is checked to ensure it is shorter
    than the data lane pairs.

Tolerances (converted from mils to mm; 1 mil = 0.0254 mm) are defined in the INTERFACE_TOLERANCES
dictionary.

**HDMI Update:**  
For HDMI the following applies:  
  - **HDMI 1.4:** Signals (TMDS0, TMDS1, TMDS2, TMDSCK) are assigned a pair tolerance of ±5 mil
    (≈0.127 mm) and an inter‑pair tolerance of ±20 mil (≈0.508 mm). Additionally, the TMDSCK (clock)
    pair is checked to ensure it is shorter than the data lanes.
  - **HDMI 2.0:** Uses the same set of signals but with tighter tolerances (±2 mil and ±10 mil).

**MIPI DSI/CSI Update:**  
For MIPI DSI/CSI the differential pairs include:  
  - DSID0_N, DSID0_P / DSID1_N, DSID1_P / DSID2_N, DSID2_P / DSID3_N, DSID3_P / DSIC_N, DSIC_P  
    with tolerances of ±2 mil (≈0.051 mm) and ±10 mil (≈0.254 mm).

**Ethernet Update:**  
For Ethernet the following applies:  
  - **Ethernet 1000BASE-T:** Differential pairs include TX1_N, TX1_P / TX2_N, TX2_P / TX3_N, TX3_P / TX4_N, TX4_P  
    with a pair tolerance of ±5 mil (≈0.127 mm) and an inter‑pair tolerance of ±10 mil (≈0.254 mm).
  - **Ethernet 10GBASE-T:** Differential pairs include TXA_N, TXA_P / TXB_N, TXB_P / TXC_N, TXC_P / TXD_N, TXD_P  
    with a pair tolerance of ±2 mil (≈0.0508 mm) and an inter‑pair tolerance of ±5 mil (≈0.127 mm).

The main window is split into two columns:
  - The left column (800 px wide) contains the signal selector and interface assignment dropdowns plus the file load, run check, and save report buttons.
  - The right column (900 px wide) displays the check results in a scrollable table.
"""

import os
import tkinter as tk
from tkinter import filedialog, messagebox
import customtkinter as ctk
import datetime

# Set dark mode and default color theme.
ctk.set_appearance_mode("Dark")
ctk.set_default_color_theme("dark-blue")

# Define interface tolerances in mm (tolerances in mils converted to mm)
INTERFACE_TOLERANCES = {
    "USB 2.0": {"pair_tol": 150 * 0.0254, "inter_pair_tol": None},
    "USB 3.0": {"pair_tol": 2 * 0.0254, "inter_pair_tol": 5 * 0.0254},
    "USB 3.1/3.2": {"pair_tol": 2 * 0.0254, "inter_pair_tol": 5 * 0.0254},
    "USB4 / Thunderbolt 3": {"pair_tol": 1 * 0.0254, "inter_pair_tol": 3 * 0.0254},
    "Ethernet 100BASE-TX": {"pair_tol": 50 * 0.0254, "inter_pair_tol": 100 * 0.0254},
    "Ethernet 1000BASE-T": {"pair_tol": 5 * 0.0254, "inter_pair_tol": 10 * 0.0254},
    "Ethernet 10GBASE-T": {"pair_tol": 2 * 0.0254, "inter_pair_tol": 5 * 0.0254},
    "HDMI 1.4": {"pair_tol": 5 * 0.0254, "inter_pair_tol": 20 * 0.0254},
    "HDMI 2.0": {"pair_tol": 2 * 0.0254, "inter_pair_tol": 10 * 0.0254},
    "DisplayPort 1.2": {"pair_tol": 3 * 0.0254, "inter_pair_tol": 10 * 0.0254},
    "DisplayPort 2.0": {"pair_tol": 2 * 0.0254, "inter_pair_tol": 5 * 0.0254},
    "PCIe Gen1/2": {"pair_tol": 5 * 0.0254, "inter_pair_tol": 20 * 0.0254},
    "PCIe Gen3": {"pair_tol": 2 * 0.0254, "inter_pair_tol": 10 * 0.0254},
    "PCIe Gen4": {"pair_tol": 1 * 0.0254, "inter_pair_tol": 5 * 0.0254},
    "PCIe Gen5": {"pair_tol": 0.5 * 0.0254, "inter_pair_tol": 2 * 0.0254},
    "SATA 3.0": {"pair_tol": 5 * 0.0254, "inter_pair_tol": 20 * 0.0254},
    "SAS 12G": {"pair_tol": 2 * 0.0254, "inter_pair_tol": 5 * 0.0254},
    "MIPI DSI/CSI": {"pair_tol": 2 * 0.0254, "inter_pair_tol": 10 * 0.0254},
    "LVDS": {"pair_tol": 5 * 0.0254, "inter_pair_tol": 20 * 0.0254},
}

# For the dropdown menu, add an "Unassigned" option as the first item.
INTERFACE_OPTIONS = list(INTERFACE_TOLERANCES.keys())
INTERFACE_OPTIONS.insert(0, "Unassigned")

def get_matching_key(signal_name):
    """
    Given a full signal name that ends with '_N' or '_P', return the grouping key.
    If the signal name has exactly two tokens (e.g. "DP_N"), the key is just the first token.
    If it has three or more tokens (e.g. "HDMI0_TDMS0_N"), the key is built from the first token
    (the expansion) and the token immediately before the trailing channel indicator.
    """
    tokens = signal_name.split("_")
    if len(tokens) == 2:
        return tokens[0]
    elif len(tokens) >= 3:
        return tokens[0] + "_" + tokens[-2]
    else:
        return signal_name

def recommend_interface_for_pair(pair):
    """
    Given a differential pair (a dict with keys "N", "P", and "key"), return a recommended interface.
    This function splits the grouping key into an expansion and a base. If an overriding recommendation
    is found based on the expansion (e.g. "PCIE" or "HDMI"), that takes precedence. Otherwise the base
    token is used.
    """
    group_key = pair["key"]
    tokens = group_key.split("_")
    if len(tokens) == 1:
        expansion = ""
        base = tokens[0]
    else:
        expansion = tokens[0]
        base = tokens[1]
    
    if expansion.upper().startswith("PCIE"):
        return "PCIe Gen1/2"
    if expansion.upper().startswith("HDMI"):
        if base.upper().startswith("TMDS") or base.upper().startswith("TDMS"):
            return "HDMI 1.4"
    if expansion.upper().startswith("USB3"):
        if base.upper() in ["SSRX", "SSTX"]:
            return "USB 3.0"
    
    pk = base.upper()
    if pk == "DP":
        return "USB 2.0"
    elif pk in ["SSRX", "SSTX"]:
        return "USB 3.0"
    elif pk in ["HSRX", "HSTX"]:
        return "USB4 / Thunderbolt 3"
    elif pk in ["TD", "RD"]:
        return "Ethernet 100BASE-TX"
    elif pk in ["TXA", "TXB", "TXC", "TXD"]:
        return "Ethernet 10GBASE-T"
    elif pk in ["TX1", "TX2", "TX3", "TX4"]:
        return "Ethernet 1000BASE-T"
    elif pk.startswith("TMDS") or pk.startswith("TDMS"):
        return "HDMI 1.4"
    elif pk.startswith("ML") or pk == "AUX":
        return "DisplayPort 1.2"
    elif pk.startswith("PCIE"):
        return "PCIe Gen1/2"
    elif pk.startswith("SATA"):
        return "SATA 3.0"
    elif pk.startswith("SAS"):
        return "SAS 12G"
    elif pk.startswith("DSID") or pk.startswith("DSIC") or pk.startswith("DSI") or pk.startswith("CSI"):
        return "MIPI DSI/CSI"
    elif pk.startswith("LVDS"):
        return "LVDS"
    return "Unassigned"

def generate_markdown_report(rows, input_filename, overall_status, timestamp):
    """
    Generate a Markdown report with a header section and a nicely formatted table.
    The overall status header is colored: green for PASS and red for FAIL.
    """
    md_lines = []
    md_lines.append(f"# Differential Pair Length Check Report")
    md_lines.append("")
    md_lines.append(f"**Input File:** {input_filename}")
    md_lines.append(f"**Date/Time:** {timestamp}")
    md_lines.append("")
    if overall_status.upper() == "PASS":
        status_str = '<span style="color:green">PASS</span>'
    else:
        status_str = '<span style="color:red">FAIL</span>'
    md_lines.append(f"# Overall Status: {status_str}")
    md_lines.append("")
    headers = ["**Group**", "**Pair**", "**Diff (mm)**", "**Tolerance (mm)**", "**Status**"]
    md_lines.append("| " + " | ".join(headers) + " |")
    md_lines.append("| " + " | ".join(["---"] * len(headers)) + " |")
    for row in rows:
        row_list = list(row)
        status = str(row_list[-1]).upper()
        if status == "PASS":
            row_list[-1] = '<span style="color:green">PASS</span>'
        elif status == "FAIL":
            row_list[-1] = '<span style="color:red">FAIL</span>'
        if row_list[1] == "-----" and row_list[0] != "":
            row_list[0] = f"**{row_list[0]}**"
        md_lines.append("| " + " | ".join(str(item) for item in row_list) + " |")
    return "\n".join(md_lines)

class DiffPairApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        self.title("Differential Pair Length Checker")
        self.geometry("1500x700")
        self.resizable(False, False)
        self.last_report = None  # Store the generated Markdown report text
        self.input_filename = "N/A"

        # Data containers.
        self.pairs = []      # List of dicts (each with keys "key", "N", "P")
        self.pair_vars = []  # List of tk.StringVar for interface assignment

        # Left frame: fixed width 700 px.
        self.left_frame = ctk.CTkFrame(self, width=700)
        self.left_frame.pack(side="left", fill="both", expand=False, padx=10, pady=5)
        self.left_frame.pack_propagate(False)

        # Right frame: fixed width 800 px.
        self.right_frame = ctk.CTkFrame(self, width=800)
        self.right_frame.pack(side="right", fill="both", expand=False, padx=10, pady=5)
        self.right_frame.pack_propagate(False)

        # --- Left Frame: File load controls and Signal Pair Selector ---
        self.top_frame = ctk.CTkFrame(self.left_frame, height=50)
        self.top_frame.pack(fill="x", padx=5, pady=5)
        self.load_button = ctk.CTkButton(self.top_frame, text="Load Signal File", command=self.load_file)
        self.load_button.pack(side="left", padx=5, pady=5)
        self.file_label = ctk.CTkLabel(self.top_frame, text="No file loaded", anchor="w")
        self.file_label.pack(side="left", padx=5, pady=5)

        self.scrollable_frame = ctk.CTkScrollableFrame(self.left_frame)
        self.scrollable_frame.pack(fill="both", expand=True, padx=5, pady=5)

        # --- Button Frame: 4-column layout (empty, Run, Save, empty) ---
        self.button_frame = ctk.CTkFrame(self.left_frame, height=50)
        self.button_frame.pack(fill="x", padx=5, pady=5)
        self.button_frame.columnconfigure(0, weight=1)
        self.button_frame.columnconfigure(1, weight=0)
        self.button_frame.columnconfigure(2, weight=0)
        self.button_frame.columnconfigure(3, weight=1)
        # Run Check button (centered in column 1) with dark green color.
        self.run_button = ctk.CTkButton(
            self.button_frame,
            text="Run Check",
            command=self.run_check,
            fg_color="#006400",      # Dark green
            hover_color="#004d00"      # Even darker green on hover
        )
        self.run_button.grid(row=0, column=1, padx=5, pady=5)
        # Save Report button (in column 2).
        self.save_button = ctk.CTkButton(
            self.button_frame,
            text="Save Report",
            command=self.save_report
        )
        self.save_button.grid(row=0, column=2, padx=5, pady=5, sticky="e")

        # --- Right Frame: Results Table (in a scrollable frame) ---
        self.result_frame = ctk.CTkScrollableFrame(self.right_frame)
        self.result_frame.pack(fill="both", expand=True, padx=5, pady=5)

    def load_file(self):
        file_path = filedialog.askopenfilename(
            title="Select Signal File",
            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")]
        )
        if not file_path:
            return
        self.input_filename = os.path.basename(file_path)
        self.file_label.configure(text=self.input_filename)
        try:
            self.pairs = self.parse_file(file_path)
            self.populate_pairs()
        except Exception as e:
            messagebox.showerror("File Load Error", f"Error loading file: {e}")

    def parse_file(self, filename):
        raw_signals = []
        with open(filename, "r") as f:
            lines = f.readlines()
        data_started = False
        for line in lines:
            line = line.strip()
            if not line:
                continue
            if not data_started:
                if "l [mm]" in line or "Signal" in line:
                    data_started = True
                continue
            parts = line.split("\t")
            if len(parts) < 2:
                continue
            signal_name = parts[0].strip()
            try:
                length = float(parts[1].strip())
            except ValueError:
                continue
            raw_signals.append((signal_name, length))
        # Keep only signals ending with _N or _P.
        filtered = [(name, length) for name, length in raw_signals if name.endswith("_N") or name.endswith("_P")]
        groups = {}  # key: grouping key, value: {"N": [], "P": []}
        for name, length in filtered:
            key = get_matching_key(name)
            channel = name[-1]  # "N" or "P"
            if key not in groups:
                groups[key] = {"N": [], "P": []}
            groups[key][channel].append((name, length))
        pairs = []
        for key, channels in groups.items():
            list_n = channels["N"]
            list_p = channels["P"]
            pair_count = min(len(list_n), len(list_p))
            for i in range(pair_count):
                pairs.append({"key": key, "N": list_n[i], "P": list_p[i]})
            if len(list_n) > pair_count:
                for extra in list_n[pair_count:]:
                    pairs.append({"key": key, "N": extra, "P": None})
            if len(list_p) > pair_count:
                for extra in list_p[pair_count:]:
                    pairs.append({"key": key, "N": None, "P": extra})
        return pairs

    def populate_pairs(self):
        # Clear the left scrollable frame.
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        self.pair_vars = []
        row = 0
        header_n = ctk.CTkLabel(self.scrollable_frame, text="Channel _N", width=200, anchor="w")
        header_n.grid(row=row, column=0, padx=5, pady=5)
        header_p = ctk.CTkLabel(self.scrollable_frame, text="Channel _P", width=200, anchor="w")
        header_p.grid(row=row, column=1, padx=5, pady=5)
        header_iface = ctk.CTkLabel(self.scrollable_frame, text="Interface", width=200, anchor="w")
        header_iface.grid(row=row, column=2, padx=5, pady=5)
        row += 1
        for pair in self.pairs:
            if pair.get("N"):
                full_name_n, _ = pair["N"]
                text_n = f"{full_name_n}"
            else:
                text_n = "Missing"
            label_n = ctk.CTkLabel(self.scrollable_frame, text=text_n, anchor="w", width=200)
            label_n.grid(row=row, column=0, padx=5, pady=2, sticky="w")
            if pair.get("P"):
                full_name_p, _ = pair["P"]
                text_p = f"{full_name_p}"
            else:
                text_p = "Missing"
            label_p = ctk.CTkLabel(self.scrollable_frame, text=text_p, anchor="w", width=200)
            label_p.grid(row=row, column=1, padx=5, pady=2, sticky="w")
            rec = recommend_interface_for_pair(pair)
            var = tk.StringVar(value=rec)
            dropdown = ctk.CTkOptionMenu(self.scrollable_frame, variable=var, values=INTERFACE_OPTIONS, width=200)
            dropdown.grid(row=row, column=2, padx=5, pady=2, sticky="w")
            self.pair_vars.append(var)
            row += 1

    def run_check(self):
        result_rows = []
        assignments = {}  # key: (assigned_iface, expansion); value: list of complete pairs
        incomplete_rows = []  # for pairs missing one channel
        for idx, pair in enumerate(self.pairs):
            assigned_iface = self.pair_vars[idx].get()
            if assigned_iface == "Unassigned":
                continue
            key = pair["key"]
            expansion = key.split("_")[0] if "_" in key else None
            group_key = (assigned_iface, expansion)
            if pair.get("N") and pair.get("P"):
                if group_key not in assignments:
                    assignments[group_key] = []
                assignments[group_key].append(pair)
            else:
                grp = f"{assigned_iface}" if not expansion else f"{assigned_iface} ({expansion})"
                incomplete_rows.append((grp, f"Incomplete pair in {pair['key']}", "", "", "FAIL"))
        
        # Process each group (sorted by interface and expansion)
        for group_key in sorted(assignments.keys(), key=lambda x: (x[0], x[1] or "")):
            assigned_iface, expansion = group_key
            grp = f"{assigned_iface}" if not expansion else f"{assigned_iface} ({expansion})"
            result_rows.append((grp, "-----", "", "", ""))
            pair_tol = INTERFACE_TOLERANCES[assigned_iface]["pair_tol"]
            inter_pair_tol = INTERFACE_TOLERANCES[assigned_iface]["inter_pair_tol"]
            pair_avgs = []
            for pair in assignments[group_key]:
                n_full, n_length = pair["N"]
                p_full, p_length = pair["P"]
                diff = abs(n_length - p_length)
                avg = (n_length + p_length) / 2.0
                pair_avgs.append(avg)
                status = "PASS" if diff <= pair_tol else "FAIL"
                pair_label = f"{n_full} / {p_full}"
                result_rows.append(("", pair_label, f"{diff:.3f}", f"±{pair_tol:.3f}", status))
            if inter_pair_tol is not None and len(pair_avgs) > 1:
                min_avg = min(pair_avgs)
                max_avg = max(pair_avgs)
                inter_diff = max_avg - min_avg
                inter_status = "PASS" if inter_diff <= inter_pair_tol else "FAIL"
                result_rows.append(("", "Inter‑Pair", f"{inter_diff:.3f}", f"±{inter_pair_tol:.3f}", inter_status))
            if assigned_iface == "HDMI 1.4":
                clock_pairs = []
                data_avgs = []
                for pair in assignments[group_key]:
                    pk = pair["key"].upper()
                    n_full, n_length = pair["N"]
                    p_full, p_length = pair["P"]
                    avg = (n_length + p_length) / 2.0
                    if "TMDSCK" in pk or "TDMSCK" in pk:
                        clock_pairs.append((pair, avg))
                    elif "TMDS" in pk or "TDMS" in pk:
                        data_avgs.append(avg)
                if clock_pairs and data_avgs:
                    min_data_avg = min(data_avgs)
                    for pair, clock_avg in clock_pairs:
                        status = "PASS" if clock_avg < min_data_avg else "FAIL"
                        pair_label = f"{pair['N'][0]} / {pair['P'][0]} (TMDSCK)"
                        result_rows.append(("", pair_label, f"{clock_avg:.3f}", "", status))
        result_rows.extend(incomplete_rows)
        if not result_rows:
            result_rows.append(("", "No pairs assigned to any interface.", "", "", ""))
        
        # Clear previous results.
        for widget in self.result_frame.winfo_children():
            widget.destroy()
        headers = ["Group", "Pair", "Diff (mm)", "Tolerance (mm)", "Status"]
        col_widths = [150, 250, 60, 60, 60]
        header_font = ("TkDefaultFont", 12, "bold")
        cell_font = ("TkDefaultFont", 10)
        for col, (htext, width) in enumerate(zip(headers, col_widths)):
            label = ctk.CTkLabel(self.result_frame, text=htext, width=width, anchor="w", font=header_font)
            label.grid(row=0, column=col, padx=2, pady=2)
        for row_idx, row_values in enumerate(result_rows, start=1):
            for col_idx, value in enumerate(row_values):
                if col_idx == len(row_values) - 1 and str(value).upper() in ["PASS", "FAIL"]:
                    txt_color = "green" if str(value).upper() == "PASS" else "red"
                    label = ctk.CTkLabel(self.result_frame, text=value, width=col_widths[col_idx],
                                          anchor="center", text_color=txt_color, font=cell_font)
                else:
                    label = ctk.CTkLabel(self.result_frame, text=value, width=col_widths[col_idx],
                                          anchor="w", font=cell_font)
                label.grid(row=row_idx, column=col_idx, padx=2, pady=2)
        
        overall_status = "PASS"
        for row in result_rows:
            if str(row[-1]).strip().upper() == "FAIL":
                overall_status = "FAIL"
                break
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.last_report = generate_markdown_report(result_rows, self.input_filename, overall_status, timestamp)

    def save_report(self):
        if not self.last_report:
            messagebox.showwarning("No Report", "There is no report to save. Please run the check first.")
            return
        save_path = filedialog.asksaveasfilename(
            title="Save Report",
            defaultextension=".md",
            filetypes=[("Markdown Files", "*.md"), ("All Files", "*.*")]
        )
        if not save_path:
            return
        try:
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(self.last_report)
            messagebox.showinfo("Report Saved", f"Report saved successfully to:\n{save_path}")
        except Exception as e:
            messagebox.showerror("Save Error", f"Error saving report: {e}")

if __name__ == "__main__":
    app = DiffPairApp()
    app.mainloop()
